<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Реклама</title>
<script src="pdf.min.js"></script>
<style>
body {
	margin: 0;
	padding: 0;
	overflow: hidden;
	background-color: white; /* Белый фон для обрезанных частей */
}
video {
	max-width: 100vw;
	height: 100vh;
	display: none;
	margin: 0 auto; /* Центрирование по горизонтали */
}
canvas#pdfCanvas {
	max-width: 100vw;
	height: 100vh;
	display: none;
	margin: 0 auto; /* Центрирование по горизонтали */
}
#fullscreenBtn {
	position: absolute;
	bottom: 30px;
	right: 20px;
	padding: 10px 20px;
	background-color: rgba(0, 0, 0, 0.7);
	color: white;
	border: none;
	border-radius: 5px;
	cursor: pointer;
	z-index: 10;
}
#fullscreenBtn:hover {
	background-color: rgba(0, 0, 0, 0.9);
}
#clientInfo {
	position: absolute;
	bottom: 7px;
	right: 20px;
	color: white;
	background-color: rgba(0, 0, 0, 0.7);
	padding: 4px;
	border-radius: 5px;
	z-index: 10;
	font-size: 11px;
	display: none; /* По умолчанию скрыто, пока не загрузится настройка */
}
</style>
</head>
<body>
<video id="adVideo" autoplay muted>
	<source src="" type="video/mp4">
</video>
<canvas id="pdfCanvas"></canvas>
<button id="fullscreenBtn">Во весь экран</button>
<div id="clientInfo"></div>
<script>
// Генерация UUID
function generateUUID() {
	return 'xxxx-4xxxyxxx-xxxx'.replace(/[xy]/g, c => {
		const r = Math.random() * 16 | 0;
		return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
	});
}
// Получение или создания UUID
let uuid = localStorage.getItem('client_uuid');
if (!uuid) {
	uuid = generateUUID();
	localStorage.setItem('client_uuid', uuid);
	fetch('api.php', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ action: 'add_client', uuid })
	}).then(() => loadClientInfo()).catch(err => console.error('Ошибка регистрации клиента:', err));
}
const video = document.getElementById('adVideo');
const pdfCanvas = document.getElementById('pdfCanvas');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const clientInfo = document.getElementById('clientInfo');
let contentList = [];
let currentIndex = 0;
let currentTime = 0;
let pdfTimer = null;
let currentContentUrl = null; // Для отслеживания текущего контента
const DEFAULT_PDF_DURATION = 5000; // 5 секунд по умолчанию для PDF

// Остановка текущего контента (только если нужно)
function stopCurrentContent(force = false) {
	if (!force && contentList.length === 1) {
		return; // Не очищаем при одном элементе, чтобы избежать моргания
	}
	video.pause();
	video.style.display = 'none';
	if (pdfTimer) {
		clearTimeout(pdfTimer);
		pdfTimer = null;
	}
	pdfCanvas.style.display = 'none';
	currentContentUrl = null;
}

// Рендеринг PDF страницы (только первая, так как одностраничные)
async function renderPDF(url) {
	const pdfDoc = await pdfjsLib.getDocument(url).promise;
	const page = await pdfDoc.getPage(1); // Только первая страница
	const viewport = page.getViewport({ scale: 1.0 });
	const ctx = pdfCanvas.getContext('2d');
	// Масштабируем по высоте экрана, сохраняя пропорции
	const scale = window.innerHeight / viewport.height; // Масштаб по высоте
	const scaledWidth = viewport.width * scale;
	pdfCanvas.width = scaledWidth;
	pdfCanvas.height = window.innerHeight;
	const scaledViewport = page.getViewport({ scale });
	await page.render({
		canvasContext: ctx,
		viewport: scaledViewport
	}).promise;
	pdfCanvas.style.display = 'block';
}

// Показ PDF с учетом продолжительности
async function showPDF(url, duration) {
	if (currentContentUrl === url && contentList.length === 1) {
		// Если тот же PDF и только один элемент, просто перезапускаем таймер
		if (pdfTimer) clearTimeout(pdfTimer);
		const displayDuration = (duration || 5) * 1000;
		pdfTimer = setTimeout(() => {
			currentIndex = 0; // Остаёмся на том же элементе
			showContent(currentIndex);
		}, displayDuration);
		return;
	}
	stopCurrentContent(); // Очищаем перед новым PDF
	await renderPDF(url);
	currentContentUrl = url;
	const displayDuration = (duration || 5) * 1000;
	pdfTimer = setTimeout(() => {
		currentIndex = (currentIndex + 1) % contentList.length;
		showContent(currentIndex);
	}, displayDuration);
}

// Обработчик окончания видео
video.addEventListener('ended', () => {
	currentIndex = (currentIndex + 1) % contentList.length;
	showContent(currentIndex);
});

// Обработчик загрузки метаданных видео для корректного масштабирования
video.addEventListener('loadedmetadata', () => {
	const videoAspectRatio = video.videoWidth / video.videoHeight;
	const scaledWidth = window.innerHeight * videoAspectRatio;
	video.style.width = `${scaledWidth}px`;
	video.style.height = '100vh';
});

// Загрузка информации об устройстве
async function loadClientInfo() {
	try {
		const response = await fetch(`api.php?action=get_client_info&uuid=${uuid}`, {
			headers: { 'Cache-Control': 'no-cache' }
		});
		const data = await response.json();
		if (data.error) {
			clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: Неизвестно`;
			clientInfo.style.display = 'none';
			console.error(data.error);
		} else {
			clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: ${data.name}`;
			clientInfo.style.display = data.show_info === 1 ? 'block' : 'none';
		}
	} catch (err) {
		clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: Ошибка загрузки`;
		clientInfo.style.display = 'none';
		console.error('Ошибка загрузки информации об устройстве:', err);
	}
}

// Функция для входа в полноэкранный режим
function enterFullscreen() {
	const element = document.documentElement;
	if (element.requestFullscreen) {
		element.requestFullscreen();
	} else if (element.mozRequestFullScreen) {
		element.mozRequestFullScreen();
	} else if (element.webkitRequestFullscreen) {
		element.webkitRequestFullscreen();
	} else if (element.msRequestFullscreen) {
		element.msRequestFullscreen();
	}
	fullscreenBtn.style.display = 'none';
	clientInfo.style.display = 'none'; // Скрываем информацию о UUID и имени
}

// Показываем кнопку и информацию при выходе из полноэкранного режима
document.addEventListener('fullscreenchange', () => {
	if (!document.fullscreenElement) {
		fullscreenBtn.style.display = 'block';
		loadClientInfo(); // Проверяем настройку видимости
	}
});
document.addEventListener('webkitfullscreenchange', () => {
	if (!document.webkitFullscreenElement) {
		fullscreenBtn.style.display = 'block';
		loadClientInfo(); // Проверяем настройку видимости
	}
});
document.addEventListener('mozfullscreenchange', () => {
	if (!document.mozFullScreenElement) {
		fullscreenBtn.style.display = 'block';
		loadClientInfo(); // Проверяем настройку видимости
	}
});
document.addEventListener('msfullscreenchange', () => {
	if (!document.msFullscreenElement) {
		fullscreenBtn.style.display = 'block';
		loadClientInfo(); // Проверяем настройку видимости
	}
});

// Обработчик события для кнопки
fullscreenBtn.addEventListener('click', enterFullscreen);

// Показ контента
async function showContent(index, restoreTime = 0) {
	if (index >= contentList.length) {
		index = 0;
	}
	if (contentList.length === 0) {
		stopCurrentContent(true);
		// Показываем ads.pdf, если плейлист пуст
		showPDF('/ads.pdf', 5);
		return;
	}
	const item = contentList[index];
	const isSingleItem = contentList.length === 1;
	if (item.type === 'video') {
		if (currentContentUrl === item.file_url && isSingleItem) {
			// Если то же видео и только один элемент, перезапускаем воспроизведение
			video.currentTime = 0;
			video.play().catch(err => console.error('Ошибка воспроизведения видео:', err));
			return;
		}
		stopCurrentContent(); // Очищаем перед новым видео
		currentIndex = index;
		video.src = item.file_url;
		video.style.display = 'block';
		video.loop = isSingleItem; // Луп только для одного видео
		video.currentTime = restoreTime;
		currentContentUrl = item.file_url;
		video.play().catch(err => console.error('Ошибка воспроизведения видео:', err));
	} else if (item.type === 'pdf') {
		currentIndex = index;
		showPDF(item.file_url, item.duration);
	}
}

// Загрузка контента
async function loadContent() {
	try {
		const response = await fetch(`api.php?action=list_client_content&uuid=${uuid}`, {
			headers: { 'Cache-Control': 'no-cache' }
		});
		const newList = await response.json();
		const isEmpty = newList.length === 0;
		const wasEmpty = contentList.length === 0;
		contentList = newList;
		currentIndex = 0;
		currentTime = 0;
		if (contentList.length > 0) {
			showContent(currentIndex);
		} else {
			stopCurrentContent(true);
			showPDF('/ads.pdf', 5); // Показываем ads.pdf, если плейлист пуст
		}
		// Принудительное обновление, если плейлист стал пустым
		if (wasEmpty !== isEmpty) {
			showContent(currentIndex);
		}
	} catch (err) {
		console.error('Ошибка загрузки контента:', err);
	}
}

// Проверка обновлений
async function checkContent() {
	try {
		const response = await fetch(`api.php?action=list_client_content&uuid=${uuid}`, {
			headers: { 'Cache-Control': 'no-cache' }
		});
		const newList = await response.json();
		if (JSON.stringify(newList) !== JSON.stringify(contentList)) {
			const wasEmpty = contentList.length === 0;
			const isEmpty = newList.length === 0;
			const currentItem = contentList[currentIndex];
			const currentId = currentItem ? `${currentItem.type}_${currentItem.id}` : null;
			contentList = newList;
			currentIndex = 0;
			let restoreTime = 0;
			if (currentItem && newList.some(item => `${item.type}_${item.id}` === currentId)) {
				currentIndex = newList.findIndex(item => `${item.type}_${item.id}` === currentId);
				if (currentIndex === -1) currentIndex = 0;
				restoreTime = currentItem && currentItem.type === 'video' ? video.currentTime : 0;
			}
			// Принудительное обновление при изменении состояния плейлиста
			stopCurrentContent(true); // Полная очистка для корректного перехода
			if (contentList.length > 0) {
				showContent(currentIndex, restoreTime);
			} else {
				showPDF('/ads.pdf', 5);
			}
		}
		loadClientInfo();
	} catch (err) {
		console.error('Ошибка проверки контента:', err);
	}
}

// Инициализация
loadClientInfo();
loadContent();
setInterval(checkContent, 1000); // Проверка каждую секунду для быстрого реагирования
</script>
</body>
</html>