<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Реклама</title>
<script src="js/pdf.min.js"></script>
<link href="css/all.min.css" rel="stylesheet">
<link href="css/style.css" rel="stylesheet">
<style>
    body {
        overflow: hidden;
    }
    #fullscreenBtn, #reconnectBtn {
        transition: opacity 0.3s ease;
    }
    .buttons-hidden {
        opacity: 0 !important;
        pointer-events: none !important;
    }
</style>
</head>
<body>
<video id="adVideo" autoplay muted>
    <source src="" type="video/mp4">
</video>
<canvas id="pdfCanvas"></canvas>
<button id="fullscreenBtn">Во весь экран</button>
<button id="reconnectBtn"><i class="fas fa-sync-alt"></i></button>
<div id="clientInfo"></div>
<div id="marquee"><span></span></div>
<script>
// Генерация UUID
function generateUUID() {
    return 'xxxx-4xxxyxxx-xxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0;
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

// Получение или создания UUID
let uuid = localStorage.getItem('client_uuid');
if (!uuid) {
    uuid = generateUUID();
    localStorage.setItem('client_uuid', uuid);
    fetch('api.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'add_client', uuid })
    }).then(() => loadClientInfo()).catch(err => console.error('Ошибка регистрации клиента:', err));
}

const video = document.getElementById('adVideo');
const pdfCanvas = document.getElementById('pdfCanvas');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const reconnectBtn = document.getElementById('reconnectBtn');
const clientInfo = document.getElementById('clientInfo');
const marquee = document.getElementById('marquee');
const marqueeText = marquee.querySelector('span');
let contentList = [];
let currentIndex = 0;
let currentTime = 0;
let pdfTimer = null;
let currentContentUrl = null;
let isRendering = false; // Флаг для отслеживания рендеринга
const DEFAULT_PDF_DURATION = 5000;
let messageSettings = { enabled: 0, text: '', color: '#ffffff', font_size: 24, speed: 100, bold: 0, background_color: '#000000' };
let lastTimeUpdate = 0;
let playbackStatus = 'playing';

// Переменные для управления таймером скрытия кнопок
let mouseMoveTimer = null;
const HIDE_BUTTONS_DELAY = 2000; // 2 секунды до скрытия кнопок

// Функция для показа кнопок
function showButtons() {
    if (messageSettings.enabled) return;
    if (document.fullscreenElement) return;
    
    fullscreenBtn.classList.remove('buttons-hidden');
    reconnectBtn.classList.remove('buttons-hidden');
    
    // Сбрасываем таймер скрытия
    if (mouseMoveTimer) {
        clearTimeout(mouseMoveTimer);
    }
    
    // Устанавливаем новый таймер для скрытия
    mouseMoveTimer = setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
}

// Функция для скрытия кнопок
function hideButtons() {
    if (messageSettings.enabled) return;
    
    fullscreenBtn.classList.add('buttons-hidden');
    reconnectBtn.classList.add('buttons-hidden');
}

// Инициализация отслеживания движения мыши
function initMouseTracking() {
    // Показываем кнопки при движении мыши
    document.addEventListener('mousemove', () => {
        showButtons();
    });
    
    // Показываем кнопки при наведении на них (на всякий случай)
    fullscreenBtn.addEventListener('mouseenter', showButtons);
    reconnectBtn.addEventListener('mouseenter', showButtons);
    
    // Изначально скрываем кнопки через 2 секунды после загрузки
    setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
}

// Функция переподключения
function reconnectClient() {
    uuid = generateUUID();
    localStorage.setItem('client_uuid', uuid);
    fetch('api.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'add_client', uuid })
    }).then(() => {
        console.log('Клиент переподключен с новым UUID:', uuid);
        loadClientInfo();
        showButtons(); // Показываем кнопки после переподключения
    }).catch(err => console.error('Ошибка переподключения клиента:', err));
}

// Остановка текущего контента
function stopCurrentContent(force = false) {
    if (!force && contentList.length === 1) {
        return;
    }
    if (video.src) {
        video.pause();
        video.removeAttribute('src'); // Удаляем src вместо присвоения ''
        video.load(); // Сбрасываем элемент видео
        console.log('Видео очищено');
    }
    video.style.display = 'none';
    if (pdfTimer) {
        clearTimeout(pdfTimer);
        pdfTimer = null;
    }
    pdfCanvas.style.display = 'none';
    const ctx = pdfCanvas.getContext('2d');
    ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    currentContentUrl = null;
    console.log('Текущий контент остановлен, force:', force);
}

// Рендеринг PDF
async function renderPDF(url) {
    if (isRendering) {
        console.log('Рендеринг уже выполняется, пропускаем:', url);
        return;
    }
    isRendering = true;
    try {
        console.log('Начало рендеринга PDF:', url);
        const pdfDoc = await pdfjsLib.getDocument(url).promise;
        const page = await pdfDoc.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });
        const ctx = pdfCanvas.getContext('2d');
        console.log('Transform before reset:', ctx.getTransform());
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        console.log('Transform after reset:', ctx.getTransform());
        const scale = window.innerHeight / viewport.height;
        const scaledWidth = viewport.width * scale;
        pdfCanvas.width = scaledWidth;
        pdfCanvas.height = window.innerHeight;
        const scaledViewport = page.getViewport({ scale });
        await page.render({
            canvasContext: ctx,
            viewport: scaledViewport,
            transform: [1, 0, 0, 1, 0, 0]
        }).promise;
        pdfCanvas.style.display = 'block';
        console.log('Рендеринг PDF завершён:', url);
    } catch (err) {
        console.error('Ошибка рендеринга PDF:', err);
    } finally {
        isRendering = false;
    }
}

// Показ PDF
async function showPDF(url, duration) {
    if (currentContentUrl === url && contentList.length === 1) {
        if (pdfTimer) clearTimeout(pdfTimer);
        const displayDuration = (duration || 5) * 1000;
        pdfTimer = setTimeout(() => {
            currentIndex = 0;
            showContent(currentIndex);
        }, displayDuration);
        console.log('Продолжаем показ PDF:', url, 'Длительность:', displayDuration);
        return;
    }
    if (isRendering) {
        console.log('Рендеринг PDF уже выполняется, пропускаем вызов showPDF:', url);
        return;
    }
    stopCurrentContent();
    await renderPDF(url);
    currentContentUrl = url;
    const displayDuration = (duration || 5) * 1000;
    pdfTimer = setTimeout(() => {
        currentIndex = (currentIndex + 1) % contentList.length;
        showContent(currentIndex);
    }, displayDuration);
    console.log('Показан новый PDF:', url, 'Длительность:', displayDuration);
}

// Обработчик окончания видео
video.addEventListener('ended', () => {
    currentIndex = (currentIndex + 1) % contentList.length;
    console.log('Видео завершено, переход к следующему:', currentIndex);
    showContent(currentIndex);
});

// Обработчик загрузки метаданных видео
video.addEventListener('loadedmetadata', () => {
    const videoAspectRatio = video.videoWidth / video.videoHeight;
    const scaledWidth = window.innerHeight * videoAspectRatio;
    video.style.width = `${scaledWidth}px`;
    video.style.height = '100vh';
    console.log('Метаданные видео загружены, размеры:', video.style.width, video.style.height);
});

// Отслеживание воспроизведения и зависания
video.addEventListener('timeupdate', () => {
    lastTimeUpdate = Date.now();
    if (playbackStatus !== 'playing') {
        playbackStatus = 'playing';
        updatePlaybackStatus();
    }
    console.log('Видео timeupdate, текущее время:', video.currentTime, 'статус:', playbackStatus);
});

video.addEventListener('pause', () => {
    if (video.ended) return; // Игнорируем паузу при завершении
    playbackStatus = 'stalled';
    updatePlaybackStatus();
    console.log('Видео приостановлено, статус:', playbackStatus);
});

video.addEventListener('error', () => {
    if (video.error && video.error.code !== 0) {
        playbackStatus = 'stalled';
        updatePlaybackStatus();
        console.error('Ошибка воспроизведения видео:', video.error.message);
    }
});

// Обновление статуса воспроизведения на сервере
async function updatePlaybackStatus() {
    try {
        const response = await fetch('api.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'update_playback_status', uuid, status: playbackStatus })
        });
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const result = await response.json();
        if (result.error) {
            console.error('Ошибка обновления статуса:', result.error);
        } else {
            console.log('Статус воспроизведения обновлён:', playbackStatus);
        }
    } catch (err) {
        console.error('Ошибка отправки статуса воспроизведения:', err);
    }
}

// Проверка зависания видео
function checkVideoStall() {
    if (video.src && !video.paused && !video.ended && video.readyState >= 2) {
        if (Date.now() - lastTimeUpdate > 2000 && playbackStatus !== 'stalled') {
            playbackStatus = 'stalled';
            updatePlaybackStatus();
            console.log('Обнаружено зависание видео, статус:', playbackStatus);
        }
    } else if (video.src && playbackStatus === 'playing') {
        // Подтверждаем playing, если видео активно
        updatePlaybackStatus();
        console.log('Видео активно, подтверждён статус:', playbackStatus);
    }
}

// Проверка команды перезапуска
async function checkRestartCommand() {
    try {
        const response = await fetch(`api.php?action=get_client_info&uuid=${uuid}`, {
            headers: { 'Cache-Control': 'no-cache' }
        });
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        console.log('Проверка команды перезапуска, данные:', data);
        if (data.error) {
            console.error('Ошибка получения информации о клиенте:', data.error);
            return;
        }
        if (data.playback_status === 'restart') {
            console.log('Получена команда перезапуска для UUID:', uuid);
            stopCurrentContent(true);
            showContent(currentIndex, 0);
            // Сбрасываем статус на playing после перезапуска
            playbackStatus = 'playing';
            await updatePlaybackStatus();
            console.log('Видео перезапущено, currentIndex:', currentIndex, 'playback_status:', playbackStatus);
        }
        if (data.restart_requested == 1) {
            console.log('Получена команда перезапуска (restart_requested) для UUID:', uuid);
            stopCurrentContent(true);
            showContent(currentIndex, 0);
            // Сбрасываем флаг на сервере
            fetch('api.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'clear_restart_flag', uuid })
            }).catch(err => console.error('Не удалось сбросить флаг:', err));
        }
    } catch (err) {
        console.error('Ошибка проверки команды перезапуска:', err);
    }
}

// Загрузка информации об устройстве
async function loadClientInfo() {
    try {
        const response = await fetch(`api.php?action=get_client_info&uuid=${uuid}`, {
            headers: { 'Cache-Control': 'no-cache' }
        });
        const data = await response.json();
        if (data.error) {
            clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: Неизвестно`;
            clientInfo.style.display = 'none';
            console.error('Ошибка получения информации о клиенте:', data.error);
        } else {
            clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: ${data.name}`;
            const shouldShow = data.show_info === 1 && !messageSettings.enabled;
            clientInfo.style.display = shouldShow ? 'block' : 'none';
            console.log('Информация о клиенте загружена:', data);
        }
    } catch (err) {
        clientInfo.textContent = `UUID: ${uuid.toUpperCase()} | ИМЯ: Неизвестно`;
        clientInfo.style.display = 'none';
        console.error('Ошибка загрузки информации о клиенте:', err);
    }
}

// Загрузка настроек сообщения
async function loadMessageSettings() {
    try {
        const response = await fetch('api.php?action=get_message_settings', {
            headers: { 'Cache-Control': 'no-cache' }
        });
        const newSettings = await response.json();
        if (JSON.stringify(newSettings) !== JSON.stringify(messageSettings)) {
            messageSettings = newSettings;
            console.log('Настройки сообщения обновлены:', messageSettings);
            if (messageSettings.enabled) {
                stopCurrentContent(true);
                marqueeText.textContent = messageSettings.text;
                marquee.style.backgroundColor = messageSettings.background_color;
                marquee.style.display = 'block';
                marquee.style.height = `${messageSettings.font_size + 20}px`;
                marqueeText.style.color = messageSettings.color;
                marqueeText.style.fontSize = `${messageSettings.font_size}px`;
                marqueeText.style.fontWeight = messageSettings.bold ? 'bold' : 'normal';
                const textWidth = marqueeText.offsetWidth;
                const duration = textWidth / messageSettings.speed;
                marqueeText.style.animationDuration = `${duration}s`;
                document.body.style.backgroundColor = messageSettings.background_color;
                fullscreenBtn.style.display = 'none';
                reconnectBtn.style.display = 'none';
                clientInfo.style.display = 'none';
                // Скрываем кнопки
                hideButtons();
            } else {
                marqueeText.textContent = '';
                marquee.style.height = '100px';
                marquee.style.display = 'none';
                document.body.style.backgroundColor = 'white';
                showContent(currentIndex, currentTime);
                loadClientInfo();
                if (!document.fullscreenElement) {
                    fullscreenBtn.style.display = 'block';
                    reconnectBtn.style.display = 'block';
                    // Показываем кнопки при отключении сообщения
                    showButtons();
                    // Скрываем через 2 секунды
                    setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
                }
            }
        }
    } catch (err) {
        console.error('Ошибка загрузки настроек сообщения:', err);
    }
}

// Функция для входа в полноэкранный режим
function enterFullscreen() {
    const element = document.documentElement;
    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
    }
    fullscreenBtn.style.display = 'none';
    reconnectBtn.style.display = 'none';
    clientInfo.style.display = 'none';
    console.log('Вход в полноэкранный режим');
}

// Обработчики событий полноэкранного режима
document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
        fullscreenBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        reconnectBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        loadClientInfo();
        // Показываем кнопки при выходе из полноэкранного режима
        if (!messageSettings.enabled) {
            showButtons();
            setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
        }
        console.log('Выход из полноэкранного режима');
    } else {
        // Скрываем кнопки при входе в полноэкранный режим
        hideButtons();
    }
});
document.addEventListener('webkitfullscreenchange', () => {
    if (!document.webkitFullscreenElement) {
        fullscreenBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        reconnectBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        loadClientInfo();
        if (!messageSettings.enabled) {
            showButtons();
            setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
        }
    } else {
        hideButtons();
    }
});
document.addEventListener('mozfullscreenchange', () => {
    if (!document.mozFullScreenElement) {
        fullscreenBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        reconnectBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        loadClientInfo();
        if (!messageSettings.enabled) {
            showButtons();
            setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
        }
    } else {
        hideButtons();
    }
});
document.addEventListener('msfullscreenchange', () => {
    if (!document.msFullscreenElement) {
        fullscreenBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        reconnectBtn.style.display = messageSettings.enabled ? 'none' : 'block';
        loadClientInfo();
        if (!messageSettings.enabled) {
            showButtons();
            setTimeout(hideButtons, HIDE_BUTTONS_DELAY);
        }
    } else {
        hideButtons();
    }
});

fullscreenBtn.addEventListener('click', enterFullscreen);
reconnectBtn.addEventListener('click', reconnectClient);

// Показ контента
async function showContent(index, restoreTime = 0) {
    if (messageSettings.enabled) {
        console.log('Контент не показывается, включено сообщение');
        return;
    }
    if (index >= contentList.length) {
        index = 0;
    }
    if (contentList.length === 0) {
        if (currentContentUrl === '/ads.pdf' && !isRendering) {
            console.log('ads.pdf уже отображается, пропускаем повторный вызов');
            return;
        }
        stopCurrentContent(true);
        showPDF('/ads.pdf', 5);
        console.log('Показываем дефолтный PDF: /ads.pdf');
        return;
    }
    const item = contentList[index];
    const isSingleItem = contentList.length === 1;
    if (item.type === 'video') {
        if (currentContentUrl === item.file_url && isSingleItem) {
            video.currentTime = 0;
            video.play().catch(err => {
                console.error('Ошибка воспроизведения видео:', err);
                playbackStatus = 'stalled';
                updatePlaybackStatus();
            });
            console.log('Перезапуск текущего видео:', item.file_url);
            return;
        }
        stopCurrentContent(true);
        currentIndex = index;
        video.src = item.file_url;
        video.style.display = 'block';
        video.loop = isSingleItem;
        video.currentTime = restoreTime;
        currentContentUrl = item.file_url;
        video.play().catch(err => {
            playbackStatus = 'stalled';
            updatePlaybackStatus();
        });
        console.log('Показываем видео:', item.file_url, 'Время:', restoreTime);
    } else if (item.type === 'pdf') {
        currentIndex = index;
        showPDF(item.file_url, item.duration);
        console.log('Запуск PDF:', item.file_url);
    }
}

// Загрузка контента
async function loadContent() {
    try {
        const response = await fetch(`api.php?action=list_client_content&uuid=${uuid}`, {
            headers: { 'Cache-Control': 'no-cache' }
        });
        const newList = await response.json();
        const isEmpty = newList.length === 0;
        const wasEmpty = contentList.length === 0;
        contentList = newList;
        currentIndex = 0;
        currentTime = 0;
        console.log('Контент загружен:', newList);
        if (contentList.length > 0 && !messageSettings.enabled) {
            showContent(currentIndex);
        } else if (!messageSettings.enabled) {
            stopCurrentContent(true);
            showPDF('/ads.pdf', 5);
        }
        if (wasEmpty !== isEmpty) {
            showContent(currentIndex);
        }
    } catch (err) {
        console.error('Ошибка загрузки контента:', err);
    }
}

// Проверка обновлений
async function checkContent() {
    try {
        console.log(`Отправка запроса list_client_content с UUID: ${uuid}`);
        const response = await fetch(`api.php?action=list_client_content&uuid=${uuid}`, {
            headers: { 'Cache-Control': 'no-cache' }
        });
        const newList = await response.json();
        console.log('Получен ответ list_client_content:', newList);
        if (JSON.stringify(newList) !== JSON.stringify(contentList)) {
            const wasEmpty = contentList.length === 0;
            const isEmpty = newList.length === 0;
            const currentItem = contentList[currentIndex];
            const currentId = currentItem ? `${currentItem.type}_${currentItem.id}` : null;
            contentList = newList;
            currentIndex = 0;
            let restoreTime = 0;
            if (currentItem && newList.some(item => `${item.type}_${item.id}` === currentId)) {
                currentIndex = newList.findIndex(item => `${item.type}_${item.id}` === currentId);
                if (currentIndex === -1) currentIndex = 0;
                restoreTime = currentItem && currentItem.type === 'video' ? video.currentTime : 0;
            }
            if (!messageSettings.enabled) {
                stopCurrentContent(true);
                if (contentList.length > 0) {
                    showContent(currentIndex, restoreTime);
                } else if (currentContentUrl !== '/ads.pdf' || !isRendering) {
                    showPDF('/ads.pdf', 5);
                }
            }
        }
        loadClientInfo();
        loadMessageSettings();
    } catch (err) {
        console.error('Ошибка проверки контента:', err);
    }
}

// Инициализация
loadClientInfo();
loadContent();
loadMessageSettings();
initMouseTracking(); // Инициализируем отслеживание мыши

setInterval(() => {
    checkVideoStall();
    checkRestartCommand();
    checkContent(); // Добавлено для периодической проверки обновлений контента
}, 3000); // Каждые 3 секунды для синхронизации переключения
</script>
</body>
</html>